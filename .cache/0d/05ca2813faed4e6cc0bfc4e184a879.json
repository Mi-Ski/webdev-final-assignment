{"id":"../node_modules/@antv/l7-layers/es/wind/models/windShader.js","dependencies":[{"name":"C:\\Users\\skiba\\Desktop\\webdev-final-assignment\\node_modules\\@antv\\l7-layers\\es\\wind\\models\\windShader.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\skiba\\Desktop\\webdev-final-assignment\\package.json","includedInParent":true,"mtime":1638980225037},{"name":"C:\\Users\\skiba\\Desktop\\webdev-final-assignment\\node_modules\\@antv\\l7-layers\\package.json","includedInParent":true,"mtime":1638979319357}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateVert = exports.updateFrag = exports.fullScreenVert = exports.fullScreenFrag = exports.drawVert = exports.drawFrag = void 0;\nvar drawVert = \"\\n precision mediump float;\\n \\n attribute float a_index;\\n \\n uniform sampler2D u_particles;\\n uniform float u_particles_res;\\n \\n varying vec2 v_particle_pos;\\n \\n void main() {\\n     vec4 color = texture2D(u_particles, vec2(\\n         fract(a_index / u_particles_res),\\n         floor(a_index / u_particles_res) / u_particles_res)\\n     );\\n                \\n     // decode current particle position from the pixel's RGBA value\\n     v_particle_pos = vec2( color.r / 255.0 + color.b, color.g / 255.0 + color.a);\\n                         \\n     gl_PointSize = 1.0;\\n     gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\\n }\";\nexports.drawVert = drawVert;\nvar drawFrag = \"\\n precision mediump float;\\n \\n uniform sampler2D u_wind;\\n uniform vec2 u_wind_min;\\n uniform vec2 u_wind_max;\\n uniform sampler2D u_color_ramp;\\n \\n varying vec2 v_particle_pos;\\n \\n void main() {\\n     vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, v_particle_pos).rg);\\n     float speed_t = length(velocity) / length(u_wind_max);\\n     \\n     // color ramp is encoded in a 16x16 texture    \\n     vec2 ramp_pos = vec2( fract(16.0 * speed_t), floor(16.0 * speed_t) / 16.0);  \\n \\n     gl_FragColor = texture2D(u_color_ramp, ramp_pos);\\n }\";\nexports.drawFrag = drawFrag;\nvar updateVert = \"\\n precision mediump float;\\n \\n attribute vec2 a_pos;\\n \\n varying vec2 v_tex_pos;\\n \\n void main() {\\n     v_tex_pos = a_pos;\\n     gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\\n     // framebuffer \\u59CB\\u7EC8\\u7528\\u94FA\\u6EE1\\u5C4F\\u5E55\\u7684 texture\\n }\";\nexports.updateVert = updateVert;\nvar updateFrag = \"\\n precision highp float;\\n \\n uniform sampler2D u_particles;\\n uniform sampler2D u_wind;\\n uniform vec2 u_wind_res;\\n uniform vec2 u_wind_min;\\n uniform vec2 u_wind_max;\\n uniform float u_rand_seed;\\n uniform float u_speed_factor;\\n uniform float u_drop_rate;\\n uniform float u_drop_rate_bump;\\n \\n varying vec2 v_tex_pos;\\n \\n // pseudo-random generator\\n const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\\n float rand(const vec2 co) {\\n float t = dot(rand_constants.xy, co);\\n     return fract(sin(t) * (rand_constants.z + t));\\n }\\n     \\n // wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\\n vec2 lookup_wind(const vec2 uv) {\\n     // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\\n     vec2 px = 1.0 / u_wind_res;\\n     vec2 vc = (floor(uv * u_wind_res)) * px;\\n     vec2 f = fract(uv * u_wind_res);\\n     vec2 tl = texture2D(u_wind, vc).rg;\\n     vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\\n     vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\\n     vec2 br = texture2D(u_wind, vc + px).rg;\\n     return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\\n }\\n \\n void main() {\\n     vec4 color = texture2D(u_particles, v_tex_pos);\\n     vec2 pos = vec2(\\n         color.r / 255.0 + color.b,\\n         color.g / 255.0 + color.a); // decode particle position from pixel RGBA\\n     vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(pos));\\n     float speed_t = length(velocity) / length(u_wind_max);\\n                 \\n     // take EPSG:4236 distortion into account for calculating where the particle moved\\n     float distortion = cos(radians(pos.y * 180.0 - 90.0));\\n     vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\\n \\n     // update particle position, wrapping around the date line\\n     pos = fract(1.0 + pos + offset);\\n     \\n     // a random seed to use for the particle drop\\n     vec2 seed = (pos + v_tex_pos) * u_rand_seed;\\n     \\n     // drop rate is a chance a particle will restart at random position, to avoid degeneration\\n     float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\\n     float drop = step(1.0 - drop_rate, rand(seed));\\n     \\n     vec2 random_pos = vec2(\\n         rand(seed + 1.3),\\n         rand(seed + 2.1));\\n         pos = mix(pos, random_pos, drop);\\n         \\n     // encode the new particle position back into RGBA\\n     gl_FragColor = vec4(\\n         fract(pos * 255.0),\\n         floor(pos * 255.0) / 255.0);\\n }\";\nexports.updateFrag = updateFrag;\nvar fullScreenVert = \"\\n     precision mediump float;\\n     \\n     attribute vec2 a_pos;\\n     \\n     varying vec2 v_tex_pos;\\n     \\n     void main() {\\n         v_tex_pos = a_pos;\\n         gl_Position = vec4(1.0 - 2.0 * a_pos, 0.0, 1.0);\\n         gl_PointSize = 100.0;\\n }\";\nexports.fullScreenVert = fullScreenVert;\nvar fullScreenFrag = \"\\n precision mediump float;\\n \\n uniform sampler2D u_screen;\\n uniform float u_opacity;\\n varying vec2 v_tex_pos;\\n \\n void main() {\\n     vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\\n     \\n     // a hack to guarantee opacity fade out even with a value close to 1.0\\n     gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\\n }\";\nexports.fullScreenFrag = fullScreenFrag;"},"sourceMaps":{"js":{"mappings":[{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":7,"column":7},"generated":{"line":7,"column":0}},{"source":"../../../src/wind/models/windShader.ts","name":"drawVert","original":{"line":7,"column":13},"generated":{"line":7,"column":4}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":7,"column":21},"generated":{"line":7,"column":12}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":7,"column":21},"generated":{"line":7,"column":15}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":7,"column":7},"generated":{"line":7,"column":680}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":30,"column":7},"generated":{"line":9,"column":0}},{"source":"../../../src/wind/models/windShader.ts","name":"drawFrag","original":{"line":30,"column":13},"generated":{"line":9,"column":4}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":30,"column":21},"generated":{"line":9,"column":12}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":30,"column":21},"generated":{"line":9,"column":15}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":30,"column":7},"generated":{"line":9,"column":574}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":50,"column":7},"generated":{"line":11,"column":0}},{"source":"../../../src/wind/models/windShader.ts","name":"updateVert","original":{"line":50,"column":13},"generated":{"line":11,"column":4}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":50,"column":23},"generated":{"line":11,"column":14}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":50,"column":23},"generated":{"line":11,"column":17}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":50,"column":7},"generated":{"line":11,"column":279}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":63,"column":7},"generated":{"line":13,"column":0}},{"source":"../../../src/wind/models/windShader.ts","name":"updateFrag","original":{"line":63,"column":13},"generated":{"line":13,"column":4}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":63,"column":23},"generated":{"line":13,"column":14}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":63,"column":23},"generated":{"line":13,"column":17}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":63,"column":7},"generated":{"line":13,"column":2528}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":131,"column":7},"generated":{"line":15,"column":0}},{"source":"../../../src/wind/models/windShader.ts","name":"fullScreenVert","original":{"line":131,"column":13},"generated":{"line":15,"column":4}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":131,"column":27},"generated":{"line":15,"column":18}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":131,"column":27},"generated":{"line":15,"column":21}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":131,"column":7},"generated":{"line":15,"column":277}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":144,"column":7},"generated":{"line":17,"column":0}},{"source":"../../../src/wind/models/windShader.ts","name":"fullScreenFrag","original":{"line":144,"column":13},"generated":{"line":17,"column":4}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":144,"column":27},"generated":{"line":17,"column":18}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":144,"column":27},"generated":{"line":17,"column":21}},{"source":"../../../src/wind/models/windShader.ts","name":null,"original":{"line":144,"column":7},"generated":{"line":17,"column":369}}],"sources":{"../../../src/wind/models/windShader.ts":"/**\n * drawProgram          drawVert drawFrag\n * screenProgram        screenVert screenFrag\n * updateProgram        updateVert updateFrag\n * fullScreenProgram    fullScreenVert fullScreenFrag\n */\nexport const drawVert = `\n precision mediump float;\n \n attribute float a_index;\n \n uniform sampler2D u_particles;\n uniform float u_particles_res;\n \n varying vec2 v_particle_pos;\n \n void main() {\n     vec4 color = texture2D(u_particles, vec2(\n         fract(a_index / u_particles_res),\n         floor(a_index / u_particles_res) / u_particles_res)\n     );\n                \n     // decode current particle position from the pixel's RGBA value\n     v_particle_pos = vec2( color.r / 255.0 + color.b, color.g / 255.0 + color.a);\n                         \n     gl_PointSize = 1.0;\n     gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n }`;\n\nexport const drawFrag = `\n precision mediump float;\n \n uniform sampler2D u_wind;\n uniform vec2 u_wind_min;\n uniform vec2 u_wind_max;\n uniform sampler2D u_color_ramp;\n \n varying vec2 v_particle_pos;\n \n void main() {\n     vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, v_particle_pos).rg);\n     float speed_t = length(velocity) / length(u_wind_max);\n     \n     // color ramp is encoded in a 16x16 texture    \n     vec2 ramp_pos = vec2( fract(16.0 * speed_t), floor(16.0 * speed_t) / 16.0);  \n \n     gl_FragColor = texture2D(u_color_ramp, ramp_pos);\n }`;\n\nexport const updateVert = `\n precision mediump float;\n \n attribute vec2 a_pos;\n \n varying vec2 v_tex_pos;\n \n void main() {\n     v_tex_pos = a_pos;\n     gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n     // framebuffer 始终用铺满屏幕的 texture\n }`;\n\nexport const updateFrag = `\n precision highp float;\n \n uniform sampler2D u_particles;\n uniform sampler2D u_wind;\n uniform vec2 u_wind_res;\n uniform vec2 u_wind_min;\n uniform vec2 u_wind_max;\n uniform float u_rand_seed;\n uniform float u_speed_factor;\n uniform float u_drop_rate;\n uniform float u_drop_rate_bump;\n \n varying vec2 v_tex_pos;\n \n // pseudo-random generator\n const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n float rand(const vec2 co) {\n float t = dot(rand_constants.xy, co);\n     return fract(sin(t) * (rand_constants.z + t));\n }\n     \n // wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n vec2 lookup_wind(const vec2 uv) {\n     // return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n     vec2 px = 1.0 / u_wind_res;\n     vec2 vc = (floor(uv * u_wind_res)) * px;\n     vec2 f = fract(uv * u_wind_res);\n     vec2 tl = texture2D(u_wind, vc).rg;\n     vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n     vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n     vec2 br = texture2D(u_wind, vc + px).rg;\n     return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n }\n \n void main() {\n     vec4 color = texture2D(u_particles, v_tex_pos);\n     vec2 pos = vec2(\n         color.r / 255.0 + color.b,\n         color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n     vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(pos));\n     float speed_t = length(velocity) / length(u_wind_max);\n                 \n     // take EPSG:4236 distortion into account for calculating where the particle moved\n     float distortion = cos(radians(pos.y * 180.0 - 90.0));\n     vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;\n \n     // update particle position, wrapping around the date line\n     pos = fract(1.0 + pos + offset);\n     \n     // a random seed to use for the particle drop\n     vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n     \n     // drop rate is a chance a particle will restart at random position, to avoid degeneration\n     float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n     float drop = step(1.0 - drop_rate, rand(seed));\n     \n     vec2 random_pos = vec2(\n         rand(seed + 1.3),\n         rand(seed + 2.1));\n         pos = mix(pos, random_pos, drop);\n         \n     // encode the new particle position back into RGBA\n     gl_FragColor = vec4(\n         fract(pos * 255.0),\n         floor(pos * 255.0) / 255.0);\n }`;\n\nexport const fullScreenVert = `\n     precision mediump float;\n     \n     attribute vec2 a_pos;\n     \n     varying vec2 v_tex_pos;\n     \n     void main() {\n         v_tex_pos = a_pos;\n         gl_Position = vec4(1.0 - 2.0 * a_pos, 0.0, 1.0);\n         gl_PointSize = 100.0;\n }`;\n\nexport const fullScreenFrag = `\n precision mediump float;\n \n uniform sampler2D u_screen;\n uniform float u_opacity;\n varying vec2 v_tex_pos;\n \n void main() {\n     vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n     \n     // a hack to guarantee opacity fade out even with a value close to 1.0\n     gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n }`;\n"},"lineCount":null}},"error":null,"hash":"949aafc099674545405508dd9c3b60fb","cacheData":{"env":{}}}